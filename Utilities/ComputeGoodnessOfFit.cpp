#include <numeric>
#include <set>
#include <iomanip>
#include <omp.h>
#include <random>

#include "QutBio.h"
#include "Homologs.hpp"
#include "OpenHausdorff.hpp"
#include "Random.hpp"
#include "Exception.hpp"

using namespace QutBio;

class ComputeGoodnessOfFit {
private:
	struct Parameters {
		bool ok = true;

		string ecdfFile;
		string aicFile;

		friend ostream& operator<<( ostream& out, const Parameters& parms ) {
			out << "Parameters:\n";
			out << "--ecdfFile " << parms.ecdfFile << endl;
			out << "--aicFile " << parms.aicFile << endl;
			return out;
		}

		void Help( ostream& out ) {
			out << "ComputeGoodnessOfFit:\n\n";

			out <<
				"--help: Gets this message." << "\n\n";

			out <<
				"--ecdfFile: The name of a tab-delimited text file which contains a series of \n"
				"(x,y) pairs in the first two lines. This would typically be one of the \n"
				"empirical distribution files generated by GetKmerDistanceDistributions." << "\n\n";

			out <<
				"--aicFile: The name of a tab-delimited text file which contains the parameters \n"
				"and AIC values for a mixture of Gaussians which is supposed to fit the \n"
				"empirical distribution, also generated by GetKmerDistanceDistributions." << "\n\n";
		}


		/// <summary> Parses and validates the arguments, returning the results in a Parameters object.
		/// </summary>
		/// <param name="arguments"></param>
		/// <returns></returns>

		Parameters( Args& arguments ) {
			if ( arguments.IsDefined( "help" ) ) {
				Help( cerr );
				ok = false;
				return;
			}

			if ( !arguments.Get( "edfFile", ecdfFile ) ) {
				cerr << "Argument 'edfFile' not defined.\n";
				ok = false;
			}

			if ( !arguments.Get( "distributionFile", aicFile ) ) {
				cerr << "Argument 'distributionFile' not defined.\n";
				ok = false;
			}

			if ( !ok ) {
				cerr << "For help, use --help\n";
			}
		}

	};
public:

	/**
	Processes a ranking file produced by KmerRank to construct intra-class and
	inter-class empirical distributions of distances.
	The format of the input dataset is (laid out in comma-separated columns):

	query_id,ignored_class_id,subject_id,ignored_class_id,distance,rank,isHomolog

	*/
	static void Run( Args args ) {
		Parameters parms( args );

		if ( !parms.ok ) return;

		cerr << parms;

		ifstream edfStream( parms.ecdfFile );

		if ( !edfStream.is_open() ) {
			throw new Exception( "Unable to open '" + parms.ecdfFile + "' for input.", FileAndLine );
		}

		CsvReader edfReader( edfStream, '\t' );
		vector<vector<string>> edfRecords;
		edfReader.Read( edfRecords );

		if ( edfRecords.size() < 2 ) {
			throw Exception( "There does not seem to be an empirical distribution in '" + parms.ecdfFile + "'.", FileAndLine );
		}

		vector<pair<double, double>> edf;

		for ( uint i = 1; i < edfRecords[0].size() && i < edfRecords[1].size(); i++ ) {
			double x = atof( edfRecords[0][i].c_str() );
			double y = atof( edfRecords[1][i].c_str() );

			edf.emplace_back( x, y );
		}

		std::sort( edf.begin(), edf.end() );

		edfStream.close();

		ifstream distributionStream( parms.aicFile );

		if ( !distributionStream.is_open() ) {
			throw new Exception( "Unable to open '" + parms.aicFile + "' for input.", FileAndLine );
		}

		IntegerDistribution dist( distributionStream );
		distributionStream.close();

		// dist.PrintPdf( cerr );

#if false
		// Tried AndersonDarling test, but it doesn't work for this data because it requires
		// sample[i] < sample[i+1] for all 0 <= i < (sample.size() - 1).
		double S = 0;
		size_t n = sample.size();

		for ( uint i = 1; i <= n; i++ ) {
			double x_i = sample[i - 1];
			double z_i = dist.Cdf( x_i );

			double x_n_i = sample[n - i];
			double z_n_i = dist.Cdf( x_n_i );

			double term = ( 2.0 * i - 1.0 ) * ( log( z_i ) + log( 1 - z_n_i ) );
			S += term;

			cerr << "x_i\t" << x_i << "\tz_i\t" << z_i << "\tx_n_i\t" << x_n_i << "\tz_n_i\t" << z_n_i << "\tterm\t" << term << "\n";
		}

		double A = double( n ) - S / double( n );

		cout << "Anderson-Darling statistic\t" << A << "\n";
#endif

		// Print a Q-Q plot instead; at least we can assess the difference visually.
		vector<pair<double, double>> qq;

		for ( auto& xy : edf ) {
			if ( xy.second == 1 ) continue;

			double x = dist.InverseCdf( xy.second );
			qq.emplace_back( x, xy.first );
		}

		cout << "theoretical";

		for ( auto qqxy : qq ) {
			cout << "\t" << qqxy.first;
		}

		cout << "\nempirical";

		for ( auto qqxy : qq ) {
			cout << "\t" << qqxy.second;
		}

		cout << "\nF";

		vector<double> quantiles = { 0.0001, 0.001, 0.01, 0.1, 0.25, 0.5, 0.75, 0.9, 0.99, 0.999, 0.9999 };

		for ( auto x : quantiles ) {
			cout << "\t" << x;
		}

		cout << "\nQuantile";

		for ( auto x : quantiles ) {
			cout << "\t" << dist.InverseCdf( x );
		}

		cout << "\n";
	}
};


int main( int argc, char** argv ) {
	try {
		Args args( argc, argv );
		ComputeGoodnessOfFit::Run( args );
	}
	catch ( Exception& ex ) {
		cerr << "Unhandled exception : " << ex.what() << " - " << ex.File() << "(" << ex.Line() << ")\n";
	}
	catch ( runtime_error& err ) {
		cerr << "Unhandled exception:\n" << err.what() << endl;
	}
	return 0;
}

mutex FragmentAggregationMode::m;
mutex QutBio::DistanceType::m;
